Zachary May
CS 541
Program 3

Build Instructions:

The Makefile offers several build options:

- The default target generates the scanner and parser then compiles everything.
- the 'test' target invokes the default target to build the parser then
  runs lite.P3 on the test input file "test.lite".
- The 'clean' target empties out the class/ directory and removes source
  files generated by jflex and jcup.

Other build notes:

- The Makefile is a bit of a mess and doesn't always seem to catch
  changes to certain source files. Try 'make clean && make' in that case.
- The scanner class generated by jflex (lite/scanner/Yylex.java) and
  its constructors are not declared public, which is a problem when
  the class needs to be used outside of its own package. The build
  target for the source file runs the generated source file through
  sed to fix that.

Project layout:

- lite/ - Top level, contains main program P3.
- lite/ast/ - Abstract Syntax Tree classes.
- lite/parse/ - Parser-related classes generated by JCup.
- lite/scanner/ - Scanner-related classes, including those generated by JFlex
  and a wrapper class that implements the JCup scanner interface.
- lite/scanner/tokens/ - Token classes (as in my Program 2). They now
  explicitly take their token type value from the generated symbol
  class (lite/parse/Symols)

Design Notes:
- For syntax elements featuring repeated elements, e.g., argument lists for function
  calls, I chose to use Vectors of the relevant type (e.g., Vector<ExpressionNode>).
  This seemed far more natural at the abstract syntax level compared to the 
  "cons list" style that arises when building the parse tree.
- I also chose to forgo the "null" subclasses. In cases like function call arguments,
  their absence was represented with an empty vector. In cases of optional features,
  e.g., labels for while loops, I simply used Java's null. What would be really nice
  would be a type-safe way of notating whether a syntactic element is required.
  Something like Haskell's Maybe type: a field of type ExpressionNode means that
  the expression is required and that requirement is enforced by the type system, while
  a field of type Maybe ExpressionNode indicates that it is an optional feature.

